2021.01.05
============

# JVM
## 가상머신
	- 컴퓨팅 환경을 소프트웨어로 구현한 것
  
## JVM
	- JAVA Virtual Machine (자바 가상 머신)
	- 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행하는 것
	- JAVA와 OS 사이에서 중개자 역할을 수행하여 JAVA가 OS에 구애받지 않고 재사용할 수 있도록 해줌
	- Garbage Collection 수행
	- 스택기반의 가상머신
  
## 자바프로그램 실행과정
	1. 프로그램이 실행되면 JVM이 OS로부터 이 프로그램이 필요로 하는 메모리를 할당받음. JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리함
	2. 자바 컴파일러가 자바 소스코드를 읽어들여 자바 바이트코드로 변환시킴
	3. Class Loader를 통해 class 파일들을 JVM으로 로딩함
	4. 로딩된 class 파일들은 Execution engine을 통해 해석됨
	5. 해석된 바이트코드는 Runtime Data Areas에 배치되어 실질적인 수행이 이루어짐
  
## JVM 구조
<div>
<img src="https://user-images.githubusercontent.com/43638508/104114711-d455a500-534a-11eb-9dc9-124aca6dcc79.PNG">
</div>

	- Class Loader : JVM 내로 클래스를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈. Runtime 시에 동적으로 클래스를 로드함. jar파일 내 저장된 클래스들을 JVM 위에 탑재하고 사용하지 않는 클래스들은 메모리에서 삭제함. 자바는 동적코드, 컴파일 타임이 아니라 런타임에 참조함. 즉, 클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크한다는 것. 그 역할을 클래스 로더가 수행
	- Execution Engine : 클래스를 실행시키는 역할. 클래스 로더가 JVM 내의 런타임 데이터 영역에 바이트 코드를 배치시키고, 이것은 실행엔진에 의해 실행됨. 자바 바이트코드는 기계가 바로 수행할 수 있는 언어보다는 비교적 인간이 보기 편한 형태로 기술된 것. 그래서 실행 엔진은 이와 같은 바이트코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경. 이때 두 가지 방식 사용
	- Interpreter : 실행 엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행. 하지만 이 방식은 인터프리터 언어의 단점인 한 줄 씩 수행으로 인한 느린 속도를 가짐
	- JIT : 인터프리터 방식의 단점을 보완하기 위해 도입된 JIT 컴파일러. 인터프리터 방식으로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일하여 네이티브 코드로 변경하고, 이후에는 더 이상 인터프리팅 하지 않고 네이티브 코드로 직접 실행하는 방식. 네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 빠르게 수행됨. JIT 컴파일러가 컴파일하는 과정은 바이트코드를 인터프리팅하는 것보다 훨씬 오래 걸리므로 한 번만 실행되는 코드라면 컴파일하지 않고 인터프리팅하는 것이 유리함. 따라서 JIT 컴파일러를 사용하는 JVM들은 내부적으로 해당 메소드가 얼마나 자주 수행되는지 체크하고, 일정 정도를 넘을 때에만 컴파일을 수행함
	- Garbage Collector : GC를 수행하는 모듈이 있음
  
# 자료형
## 자료형
	- 자료형 : 데이터가 갖는 형. 데이터의 실질적인 구조, 개념을 의미
	- 자바 자료형 : 기본 자료형 / 참조 자료형
	- 기본 자료형 : 정수형 / 실수형 / 논리형 / 문자형
  
## 기본 자료형
### 정수형
<div>
<img src="https://user-images.githubusercontent.com/43638508/104115018-18967480-534e-11eb-8c15-907fc27c3536.png">
</div>

  * long 타입 사용 시 맨 끝에 소문자 l 이나 대문자 L 을 붙여야 함

### 실수형
<div>
<img src="https://user-images.githubusercontent.com/43638508/104115053-6dd28600-534e-11eb-8e16-974db313e1b5.png">
</div>

  * float 타입 사용 시 맨 끝에 소문자 f 나 대문자 F 를 붙여야 함

### 논리형
	- boolean
	- true, false
	- 1byte
	- 형 변환 불가능

### 문자형
	- 유일하게 음수가 없는 자료형
	- 2byte (유니코드를 사용하기 때문)

# equals vs ==
## 공통점
	- 양 쪽에 있는 내용을 비교한 값을 boolean형으로 반환
## 차이점
	- 형태 : equals()는 메소드이고 객체끼리 내용을 비교할 수 있음. ==는 비교를 위한 연산자
	- 주소값 비교와 내용 비교 : equals 메소드는 비교하고자 하는 대상의 내용 자체를 비교하지만, == 연산자는 비교하고자 하는 대상의 주소값을 비교

# 메소드란?
## 메소드
	- 특정 기능을 정의한 코드들의 집합
## 메소드 구조?
리턴타입 메소드이름(파라미터){ ... return 반환값;}

	- 반환값이 없는 경우 리턴타입에 void
	- 메소드이름은 보통 해당 메소드가 하는 기능을 표현하는 함축적인 단어 선택
	- 파라미터(입력값)는 0개부터 여러개까지 가능
	- 리턴타입이 void가 아닌 경우 반드시 해당 반환타입과 어울리는 변수나 상수값을 반환해야 함
## 목적
	- 불필요하게 중복되어 사용하는 코드를 메소드로 정의하고 호출함으로써 가독성을 높임
	- 코드에 문제가 생길 때 문제가 되는 메소드만 수정하면 됨으로써 유지보수에 도움이 됨

# String vs StringBuffer vs StringBuilder
	- String : 문자열 연산이 적고 멀티쓰레드 환경일 경우 사용
	- StringBuffer : 문자열 연산이 많고 멀티쓰레드 환경일 경우 사용
	- StringBuilder : 문자열 연산이 많고 단일쓰레드이거나 동기화를 고려하지 않아도 되는 경우
<div>
<img src="https://user-images.githubusercontent.com/43638508/104115230-5a281f00-5350-11eb-9b18-45650cc017ec.png">
</div>

# 리스트 3가지 특징
	- 크기가 고정되어 있지 않음(가변)
	- 순서가 있는 데이터의 모임
	- 순차성을 보장하지 못함

# 배열 vs 리스트
## 배열
### 특징
	- 같은 자료형을 가진 변수를 하나로 나타낸 것
	- 연속된 메모리 공간으로 이루어져 있음
	- 정적 표현
	- 인덱스를 이용하여 표현
	- 지역성을 가지고 있음
### 장점
	- 인덱스를 통한 검색이 용이
	- 연속적이므로 메모리 관리 편함
### 단점
	- 한 데이터를 삭제하더라도 배열은 연속해야 하므로 공간이 남음. 즉, 메모리 낭비
	- 정적이므로 배열의 크기를 컴파일 이전에 정해주어야 함
	- 컴파일 이후 배열의 크기를 변동할 수 없음
## 리스트
### 특징
	- 순서가 있는 데이터의 집합
	- 불연속적으로 메모리 공간을 차지
	- 동적 표현
	- 인덱스가 없음
	- 포인터를 통한 접근
### 장점
	- 포인터를 통하여 다음 데이터의 위치를 가리키고 있어 삽입 삭제 용이
	- 동적이므로 크기가 정해져 있지 않음
	- 메모리의 재사용 편리
	- 불연속적이므로 메모리 관리 편리
### 단점
	- 검색 성능이 좋지 않음
	- 포인터를 통해 다음 데이터를 가리켜므로 추가적인 메모리 공간 발생
## 정리
	- 배열 : 데이터의 크기가 정해져 있고, 추가적인 삽입 삭제가 일어나지 않으며, 검색을 필요로 할 때 유리
	- 리스트 : 데이터의 크기가 정해져 있지 않고, 삽입 삭제가 많이 일어나며, 검색이 적은 경우 유리
  
* * *
  
2021.01.08
============

# 파일 입출력
## 파일 입력
~~~java
package InputOutputStream;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class OutputSTreamEX {
    public static void main(String[] args) {
	try {
	    OutputStream output = new FileOutputStream("파일 위치");
	    String str ="입력 내용";
	    byte[] by=str.getBytes();
	    output.write(by);
			
	} catch (Exception e) {
            e.getStackTrace();
	}
    }
}
~~~
## 파일 출력
~~~java
package InputOutputStream;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class InputStreamEx {
    public static void main(String[] args) {
        try{
        //파일 객체 생성
        File file = new File("파일 위치");
         //입력 스트림 생성
         FileReader file_reader = new FileReader(file);
         int cur = 0;
         while((cur = file_reader.read()) != -1){
            System.out.print((char)cur);
         }
         file_reader.close();
        }catch (FileNotFoundException e) {
            e.getStackTrace();
        }catch(IOException e){
            e.getStackTrace();
        }
    }
}
~~~~

# 객체지향 3요소
## Encapsulation (캡슐화, 은닉화)
	- 값의 보호를 위해 객체의 필드, 메소드를 필요에 의해 감추거나 들어내는 것
	- 외부에서부터의 잘못된 접근으로 인해 객체의 데이터나 메소드에 유효하지 않은 값이 들어가 시스템 전체에 영향을 끼치는 것을 방지하기 위한 것
	- 접근 제한자 사용
## Inheritance (상속)
	- 부모클래스의 필드를 자식 클랙스가 물려받는 것
## Polymorphism (다형성)
	- 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질

# 클래스~메소드 구조
## 이거는 무슨 말인지 모르겠어서 패스

# 변수 유효범위
## 지역 변수
	- 메소드 내부에 선언하며 메소드 외에서는 사용할 수 없음
	- 스택 메모리에 생성
## 멤버 변수
	- new 키워드로 인스턴스를 생성해야 사용 가능
	- 해당 클래스의 메소드에서 사용 가능
	- 힙 메모리에 생성
## static 변수
	- 프로그램 실행시 클래스를 메모리에 로드했을 때부터 생성됨
	- 인스턴스를 new로 생성하지 않아도 사용 가능
	- 데이터 영역에 생성
  
# 인터페이스 vs 추상클래스
	- 클래스 아님 / 클래스임
	- 클래스와 관련 없음 / 클래스와 관련 있음
	- 한 개의 클래스에 여러 개를 사용할 수 있음 / 사용할 수 없음
	- 구현 객체의 같은 동작을 보장하기 위한 목적 / 상속을 받아서 기능을 확장시키는 데 목적


2021.01.12
===========

# 패키지
	- 비슷한 성격의 자바 클래스들을 모아 넣는 자바의 디렉토리
	- 패키지의 이름과 같은 디렉토리 내에 클래스 파일들을 포함하며 하위 패키지도 포함하는 중첩된 구조 가능
	- package 키워드 사용 ex) package jump2java.house;
## 서브패키지
	- 도트(.)를 이용하여 하위 패키지를 계속해서 만들 수 있음
## 사용법
	- import 사용
	- * : 패키지 내의 모든 클래스를 import
	- 같은 패키지 내에서는 import 없이 가능
## 장점
	- 클래스의 분류 용이
	- 패키지가 다르면 동일한 클래스명 사용 가능

# 접근제어자
<div>
<img src="https://user-images.githubusercontent.com/43638508/104541891-d62ea980-5665-11eb-8cea-16b1e9806316.png">
</div>

# static과final
## static
	- 메모리에 한 번 할당되어 프로그램이 종료될 때 해제되는 것
	- 자주 사용하면 프로그램의 종료시까지 메모리가 할당된 채로 존재
### static 변수
	- 메모리에 고정적으로 할당되어, 프로그램이 종료될 때 해제되는 변수
### static 메소드
	- 객체의 생성없이 호출 가능하며, 객체에서는 호출이 가능은 하지만 지양
	- 유틸리티 관련 함수
## final
### 원시 타입
	- 로컬 원시 변수에 final로 선언하면 한번 초기화된 변수는 변경할 수 없는 상수 값이 됨
	- ex) final int x = 1; -> x값 변경 불가
### 객체 타입
	- 객체 변수에 final로 선언하면 그 변수에 다른 참조 값을 지정할 수 없음
	- 한번 쓰여진 변수는 재변경 불가
	- 단, 객체의 속성은 변경 가능
	- ex)	final Pet pet = new Pet(); -> 다른 객체로 변경 불가
		pet.setWeight(3); -> 객체 필드 변경 가능
### 메서드 인자
	- 메서드 인자에 final 키워드를 붙이면, 메서드 안에서 변수값을 변경할 수 없음
	- ex)	public void setWeight(final int weight){
			weight = 1; -> 메서드 안에서 변경 불가
		}
### 그 외는 https://advenoh.tistory.com/13 참고
