2021.01.05
============

# JVM
## 가상머신
- 컴퓨팅 환경을 소프트웨어로 구현한 것
  
## JVM
- JAVA Virtual Machine (자바 가상 머신)
- 자바 애플리케이션을 클래스 로더를 통해 읽어 들여 자바 API와 함께 실행하는 것
- JAVA와 OS 사이에서 중개자 역할을 수행하여 JAVA가 OS에 구애받지 않고 재사용할 수 있도록 해줌
- Garbage Collection 수행
- 스택기반의 가상머신
  
## 자바프로그램 실행과정
1. 프로그램이 실행되면 JVM이 OS로부터 이 프로그램이 필요로 하는 메모리를 할당받음. JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리함
2. 자바 컴파일러가 자바 소스코드를 읽어들여 자바 바이트코드로 변환시킴
3. Class Loader를 통해 class 파일들을 JVM으로 로딩함
4. 로딩된 class 파일들은 Execution engine을 통해 해석됨
5. 해석된 바이트코드는 Runtime Data Areas에 배치되어 실질적인 수행이 이루어짐
  
## JVM 구조
<div>
<img src="https://user-images.githubusercontent.com/43638508/104114711-d455a500-534a-11eb-9dc9-124aca6dcc79.PNG">
</div>

- Class Loader : JVM 내로 클래스를 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈. Runtime 시에 동적으로 클래스를 로드함. jar파일 내 저장된 클래스들을 JVM 위에 탑재하고 사용하지 않는 클래스들은 메모리에서 삭제함. 자바는 동적코드, 컴파일 타임이 아니라 런타임에 참조함. 즉, 클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크한다는 것. 그 역할을 클래스 로더가 수행
- Execution Engine : 클래스를 실행시키는 역할. 클래스 로더가 JVM 내의 런타임 데이터 영역에 바이트 코드를 배치시키고, 이것은 실행엔진에 의해 실행됨. 자바 바이트코드는 기계가 바로 수행할 수 있는 언어보다는 비교적 인간이 보기 편한 형태로 기술된 것. 그래서 실행 엔진은 이와 같은 바이트코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경. 이때 두 가지 방식 사용
- Interpreter : 실행 엔진은 자바 바이트 코드를 명령어 단위로 읽어서 실행. 하지만 이 방식은 인터프리터 언어의 단점인 한 줄 씩 수행으로 인한 느린 속도를 가짐
- JIT : 인터프리터 방식의 단점을 보완하기 위해 도입된 JIT 컴파일러. 인터프리터 방식으로 실행하다가 적절한 시점에 바이트코드 전체를 컴파일하여 네이티브 코드로 변경하고, 이후에는 더 이상 인터프리팅 하지 않고 네이티브 코드로 직접 실행하는 방식. 네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일된 코드는 빠르게 수행됨. JIT 컴파일러가 컴파일하는 과정은 바이트코드를 인터프리팅하는 것보다 훨씬 오래 걸리므로 한 번만 실행되는 코드라면 컴파일하지 않고 인터프리팅하는 것이 유리함. 따라서 JIT 컴파일러를 사용하는 JVM들은 내부적으로 해당 메소드가 얼마나 자주 수행되는지 체크하고, 일정 정도를 넘을 때에만 컴파일을 수행함
- Garbage Collector : GC를 수행하는 모듈이 있음
  
# 자료형
## 자료형
- 자료형 : 데이터가 갖는 형. 데이터의 실질적인 구조, 개념을 의미
- 자바 자료형 : 기본 자료형 / 참조 자료형
- 기본 자료형 : 정수형 / 실수형 / 논리형 / 문자형
  
## 기본 자료형
### 정수형
<div>
<img src="https://user-images.githubusercontent.com/43638508/104115018-18967480-534e-11eb-8c15-907fc27c3536.png">
</div>

  * long 타입 사용 시 맨 끝에 소문자 l 이나 대문자 L 을 붙여야 함

### 실수형
<div>
<img src="https://user-images.githubusercontent.com/43638508/104115053-6dd28600-534e-11eb-8e16-974db313e1b5.png">
</div>

  * float 타입 사용 시 맨 끝에 소문자 f 나 대문자 F 를 붙여야 함

### 논리형
- boolean
- true, false
- 1byte
- 형 변환 불가능

### 문자형
- 유일하게 음수가 없는 자료형
- 2byte (유니코드를 사용하기 때문)

# equals vs ==
## 공통점
- 양 쪽에 있는 내용을 비교한 값을 boolean형으로 반환
## 차이점
- 형태 : equals()는 메소드이고 객체끼리 내용을 비교할 수 있음. ==는 비교를 위한 연산자
- 주소값 비교와 내용 비교 : equals 메소드는 비교하고자 하는 대상의 내용 자체를 비교하지만, == 연산자는 비교하고자 하는 대상의 주소값을 비교

# 메소드란?
## 메소드
- 특정 기능을 정의한 코드들의 집합
## 메소드 구조?
리턴타입 메소드이름(파라미터){ ... return 반환값;}

- 반환값이 없는 경우 리턴타입에 void
- 메소드이름은 보통 해당 메소드가 하는 기능을 표현하는 함축적인 단어 선택
- 파라미터(입력값)는 0개부터 여러개까지 가능
- 리턴타입이 void가 아닌 경우 반드시 해당 반환타입과 어울리는 변수나 상수값을 반환해야 함
## 목적
- 불필요하게 중복되어 사용하는 코드를 메소드로 정의하고 호출함으로써 가독성을 높임
- 코드에 문제가 생길 때 문제가 되는 메소드만 수정하면 됨으로써 유지보수에 도움이 됨

# String vs StringBuffer vs StringBuilder
- String : 문자열 연산이 적고 멀티쓰레드 환경일 경우 사용
- StringBuffer : 문자열 연산이 많고 멀티쓰레드 환경일 경우 사용
- StringBuilder : 문자열 연산이 많고 단일쓰레드이거나 동기화를 고려하지 않아도 되는 경우
<div>
<img src="https://user-images.githubusercontent.com/43638508/104115230-5a281f00-5350-11eb-9b18-45650cc017ec.png">
</div>

# 리스트 3가지 특징
- 크기가 고정되어 있지 않음(가변)
- 순서가 있는 데이터의 모임
- 순차성을 보장하지 못함

# 배열 vs 리스트
## 배열
### 특징
- 같은 자료형을 가진 변수를 하나로 나타낸 것
- 연속된 메모리 공간으로 이루어져 있음
- 정적 표현
- 인덱스를 이용하여 표현
- 지역성을 가지고 있음
### 장점
- 인덱스를 통한 검색이 용이
- 연속적이므로 메모리 관리 편함
### 단점
- 한 데이터를 삭제하더라도 배열은 연속해야 하므로 공간이 남음. 즉, 메모리 낭비
- 정적이므로 배열의 크기를 컴파일 이전에 정해주어야 함
- 컴파일 이후 배열의 크기를 변동할 수 없음
## 리스트
### 특징
- 순서가 있는 데이터의 집합
- 불연속적으로 메모리 공간을 차지
- 동적 표현
- 인덱스가 없음
- 포인터를 통한 접근
### 장점
- 포인터를 통하여 다음 데이터의 위치를 가리키고 있어 삽입 삭제 용이
- 동적이므로 크기가 정해져 있지 않음
- 메모리의 재사용 편리
- 불연속적이므로 메모리 관리 편리
### 단점
- 검색 성능이 좋지 않음
- 포인터를 통해 다음 데이터를 가리켜므로 추가적인 메모리 공간 발생
## 정리
- 배열 : 데이터의 크기가 정해져 있고, 추가적인 삽입 삭제가 일어나지 않으며, 검색을 필요로 할 때 유리
- 리스트 : 데이터의 크기가 정해져 있지 않고, 삽입 삭제가 많이 일어나며, 검색이 적은 경우 유리
  
* * *
  
2021.01.08
============

# 파일 입출력
## 파일 입력
~~~java
package InputOutputStream;

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

public class OutputSTreamEX {
    public static void main(String[] args) {
	try {
	    OutputStream output = new FileOutputStream("파일 위치");
	    String str ="입력 내용";
	    byte[] by=str.getBytes();
	    output.write(by);
			
	} catch (Exception e) {
            e.getStackTrace();
	}
    }
}
~~~
## 파일 출력
~~~java
package InputOutputStream;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

public class InputStreamEx {
    public static void main(String[] args) {
        try{
        //파일 객체 생성
        File file = new File("파일 위치");
         //입력 스트림 생성
         FileReader file_reader = new FileReader(file);
         int cur = 0;
         while((cur = file_reader.read()) != -1){
            System.out.print((char)cur);
         }
         file_reader.close();
        }catch (FileNotFoundException e) {
            e.getStackTrace();
        }catch(IOException e){
            e.getStackTrace();
        }
    }
}
~~~~

# 객체지향 3요소
## Encapsulation (캡슐화, 은닉화)
- 값의 보호를 위해 객체의 필드, 메소드를 필요에 의해 감추거나 들어내는 것
- 외부에서부터의 잘못된 접근으로 인해 객체의 데이터나 메소드에 유효하지 않은 값이 들어가 시스템 전체에 영향을 끼치는 것을 방지하기 위한 것
- 접근 제한자 사용
## Inheritance (상속)
- 부모클래스의 필드를 자식 클랙스가 물려받는 것
## Polymorphism (다형성)
- 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질

# 클래스~메소드 구조
## 이거는 무슨 말인지 모르겠어서 패스

# 변수 유효범위
## 지역 변수
- 메소드 내부에 선언하며 메소드 외에서는 사용할 수 없음
- 스택 메모리에 생성
## 멤버 변수
- new 키워드로 인스턴스를 생성해야 사용 가능
- 해당 클래스의 메소드에서 사용 가능
- 힙 메모리에 생성
## static 변수
- 프로그램 실행시 클래스를 메모리에 로드했을 때부터 생성됨
- 인스턴스를 new로 생성하지 않아도 사용 가능
- 데이터 영역에 생성

# 인터페이스 vs 추상클래스
- 클래스 아님 / 클래스임
- 클래스와 관련 없음 / 클래스와 관련 있음
- 한 개의 클래스에 여러 개를 사용할 수 있음 / 사용할 수 없음
- 구현 객체의 같은 동작을 보장하기 위한 목적 / 상속을 받아서 기능을 확장시키는 데 목적


2021.01.12
===========

# 패키지
- 비슷한 성격의 자바 클래스들을 모아 넣는 자바의 디렉토리
- 패키지의 이름과 같은 디렉토리 내에 클래스 파일들을 포함하며 하위 패키지도 포함하는 중첩된 구조 가능
- package 키워드 사용 ex) package jump2java.house;
## 서브패키지
- 도트(.)를 이용하여 하위 패키지를 계속해서 만들 수 있음
## 사용법
- import 사용
- * : 패키지 내의 모든 클래스를 import
- 같은 패키지 내에서는 import 없이 가능
## 장점
- 클래스의 분류 용이
- 패키지가 다르면 동일한 클래스명 사용 가능

# 접근제어자
<div>
<img src="https://user-images.githubusercontent.com/43638508/104541891-d62ea980-5665-11eb-8cea-16b1e9806316.png">
</div>

# static과final
## static
- 메모리에 한 번 할당되어 프로그램이 종료될 때 해제되는 것
- 자주 사용하면 프로그램의 종료시까지 메모리가 할당된 채로 존재
### static 변수
- 메모리에 고정적으로 할당되어, 프로그램이 종료될 때 해제되는 변수
### static 메소드
- 객체의 생성없이 호출 가능하며, 객체에서는 호출이 가능은 하지만 지양
- 유틸리티 관련 함수
## final
### 원시 타입
- 로컬 원시 변수에 final로 선언하면 한번 초기화된 변수는 변경할 수 없는 상수 값이 됨
- ex) final int x = 1; -> x값 변경 불가
### 객체 타입
- 객체 변수에 final로 선언하면 그 변수에 다른 참조 값을 지정할 수 없음
- 한번 쓰여진 변수는 재변경 불가
- 단, 객체의 속성은 변경 가능
- ex)	final Pet pet = new Pet(); -> 다른 객체로 변경 불가
	pet.setWeight(3); -> 객체 필드 변경 가능
### 메서드 인자
- 메서드 인자에 final 키워드를 붙이면, 메서드 안에서 변수값을 변경할 수 없음
- ex)	public void setWeight(final int weight){
		weight = 1; -> 메서드 안에서 변경 불가
	}
### 그 외는 https://advenoh.tistory.com/13 참고

2021.01.15
=============
# SOLID
## SRP (단일 책임의 원칙)
- 작성된 클래스는 하나의 기능만 가짐
- 모든 서비스는 그 하나의 책임을 수행하는 데 집중되어야 함
- 한 책임의 변경에서 다른 책임의 변경으로의 연쇄작용이 자유로움
- 코드 가독성 향상, 유지보수 용이
- 다른 원리들을 적용하는 기초
## OCP (개방폐쇄의 원칙)
- 소프트웨어의 구성요소는 확장에는 열려있고, 변경에는 닫혀있어야 함
- 변경을 위한 비용은 가능한 줄이고 확장을 위한 비용은 가능한 극대화 해야 함
- 요구사항의 변경이나 추가사항이 발생하더라도 기존 구성요소는 수정이 일어나면 안되며, 기존 구성요소를 쉽게 확장해서 재사용할 수 있어야 함
- 추상화와 다형성
## LSP (리스코브 치환의 원칙)
- 서브 타입은 언제나 기반 타입과 호환될 수 있어야 함
- 서브 타입은 기반 타입이 약속한 규약을 지켜야 함
## ISP (인터페이스 분리의 원칙)
- 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 함
- 어떤 클래스가 다른 클래스에 종속될 때에는 가능한 최소한의 인터페이스만을 사용해야 함
## DIP (의존성역전의 원칙)
- 구조적 디자인에서 발생하던 하위 레벨 모듈의 변경이 상위 레벨 모듈의 변경을 요구하는 위계관계를 끊는 의미의 역전
- 실제 사용 관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고 받음으로써 관계를 최대한 느슨하게 만듦

# 스트래티지 패턴
- 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴
- 전략을 쉽게 바꿀 수 있도록 해주는 디자인 패턴

2021.01.19
==============
# 예외
- 실행 중 오동작이나 결과에 악영향을 미치는 예상치 못한 상황
- 예외가 발생하면 자바 플랫폼이 가장 먼저 알게 되고, 실행중인 자바 응용 프로그램에 전달함
- 예외를 전달받은 응용프로그램이 예외에 대응하지 못할 경우, 자바 플랫폼이 프로그램을 강제 종료 시킴

## 예외 종류
<div>
<img src="https://user-images.githubusercontent.com/43638508/105659346-e2d7bb00-5f0b-11eb-92c4-dd4b1539346a.png">
</div>

## 예외 처리
### try-catch-finally
	try {
	  예외가 발생할 가능성이 있는 실행문(try 블록)
	}
	catch (처리할 예외 타입 선언){
	  예외 처리문(catch 블록)
	}
	finally {
	  예외 발생 여부와 상관없이 무조건 실행되는 문장(finally 블록)
	}

### throw / throws
- 사용자가 직접 예외를 생성하여 만들 때 사용
- throw : 강제로 예외를 발생시킬 때
- throws : 예외가 발생한 메소드를 호출한 곳으로 예외를 넘길 때

# 쓰레드(Thread)
- 운영 체제에 의해 관리되는 하나의 작업
- 자바로 코딩한 프로그램을 실행하면 자바 가상머신이 하나의 쓰레드 생성
- main 메소드를 실행하는 쓰레드를 main 쓰레드라고 함
- 순서와 상관없이 실행

2021.01.22
===========
# GUI
- 그래픽을 통해 유저와 상호작요하는 인터페이스
- CLI(콘솔)과 반대의 개념
## AWT vs Swing
<div>
<img src="https://user-images.githubusercontent.com/43638508/105660183-d2284480-5f0d-11eb-9cfd-8fcd342b020e.png">
</div>

## Layout
### FlowLayout(FlowLayout.정렬방향, 좌우간격, 상하간격)
- 왼쪽에서 오른쪽으로, 자리가 없을 시 아래로 배치
### BoraderLayout(좌우간격, 상하간격)
- 센터를 중심으로 동서남북 총 5개의 영역으로 나누어 배치
### GridLayout(행, 열)
- n행, n열로 구역을 나누어 배치
